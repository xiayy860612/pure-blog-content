# MySQL Schema

良好的逻辑设计和物理设计时高性能的基石.

尽量避免使用NULL, 尤其是用于索引的列

## 数据类型

数字:

- 整数
    - tinyint/smallint/mediumint/int/bigint, unsigned可选
- 实数
    - Float/Double, 浮点计算
    - DECIMAL, 存储精确的小数, 一般可使用bigint来代替decimal, 通过乘以相应的倍数即可

字符串:

- 字符
    - char, 定长, 适合更新频繁的列或者长度固定的列
    - varchar, 变长, 需要额外的1或2个字节来存储长度, 小于等于255则1个字节, 大于则2个字节; 不适合更新频繁的列, 会导致碎片化
    - text
- 二进制
    - binary
    - varbinary
    - blob

时间:

- datetime, 从1001到9999年, 精度为秒, 把日期和时间封装到格式为**YYYYMMDDHHMMSS**的整数中, 显示与时区无关, 使用8字节存储
- timestamp, 同unit时间戳, 从新纪元时间(1970-01-01T00:00:00)以来的秒数, 使用4字节存储, 只能表示1970到2038年, 显示依赖于时区, 会根据时区不同, 显示对应的时间; 对应的列默认为NOT NULL.

## id列

**整数通常是id列最好的选择**

随机值会分布在很大的空间中, 导致insert和select变慢.
因为插入值会随机写到索引的不同位置, 导致insert语句变慢;
由于数据分布在很大的空间中, 也就导致了select指定的数据会变慢;
还会导致缓存失效.

**按顺序的插入能够保证数据很快插入, 并保证数据集中在一定的范围之内.
递增插入是比较好的选择.**

### 特殊类型处理

**uuid**, 移除'-' => 使用unhex()转换uuid为16 bytes的数字, 存储到binary(16)列中 => 使用hex来解析得到uuid的值

```
mysql> select uuid();
+--------------------------------------+
| uuid()                               |
+--------------------------------------+
| e8dc60bb-6df3-11e8-8915-0800273063ab |
+--------------------------------------+
1 row in set

mysql> select unhex('e8dc60bb6df311e889150800273063ab');
+-------------------------------------------+
| unhex('e8dc60bb6df311e889150800273063ab') |
+-------------------------------------------+
| ��`�m��
+-------------------------------------------+
1 row in set

mysql> select hex(unhex('e8dc60bb6df311e889150800273063ab'));
+------------------------------------------------+
| hex(unhex('e8dc60bb6df311e889150800273063ab')) |
+------------------------------------------------+
| E8DC60BB6DF311E889150800273063AB               |
+------------------------------------------------+
1 row in set

```

**ip地址**, 使用无符号整数存储, 使用inet_aton将ip转换为数字, 使用inet_ntoa将数字转换为ip

```
mysql> select inet_aton('192.168.0.1');
+--------------------------+
| inet_aton('192.168.0.1') |
+--------------------------+
|               3232235521 |
+--------------------------+
1 row in set

mysql> select inet_ntoa(3232235521);
+-----------------------+
| inet_ntoa(3232235521) |
+-----------------------+
| 192.168.0.1           |
+-----------------------+
1 row in set

```

## schema

MySQL的存储引擎API需要在服务器曾和存储引擎层之间通过**行缓冲**格式拷贝数据, 
然后在服务器层将缓冲内容解码成各个列.

- 避免太多的列, 从行缓冲中将编码过的列转换成行数据结构的代价是很高的, 这个代价依赖于列的数量
- 避免太多的关联, MySQL限制了最多只能关联61张表


