# Schema与数据类型优化

## 数据类型的选择

MySQL基础数据类型

- 数字
    - 整数
        - tinyint/smallint/mediumint/int/bigint
        - unsigned可选
    - 实数
        - Float/Double, 浮点计算
        - DECIMAL, 存储精确的小数, 一般可使用bigint来代替decimal, 通过乘以相应的倍数即可
- 字符串
    - char, 定长, 适合更新频繁的列或者长度固定的列
    - varchar, 变长, 需要额外的1或2个字节来存储长度, 小于等于255则1个字节, 大于则2个字节; 不适合更新频繁的列, 会导致碎片化
    - text, 很长的字符串
- 二进制字符串, 比较时以字节为单位进行比较, 效率要比普通字符串要高
    - binary, 定长
    - varbinary, 变长
    - blob, 很长的二进制字符串
- 时间
    - datetime, 从1001到9999年, 精度为秒, 把日期和时间封装到格式为**YYYYMMDDHHMMSS**的**整数**中, 显示**与时区无关**, **使用8字节存储**
    - timestamp, 同unit时间戳, 从新纪元时间(1970-01-01T00:00:00)以来的秒数, **使用4字节存储**, 只能表示1970到2038年, 显示依赖于时区, 会根据时区不同, 显示对应的时间; 对应的列默认为NOT NULL.

### 特殊数据类型的处理

uuid数据的处理:

1. 移除uuid中的**-**
2. 使用unhex函数将uuid字符串转换为16字节的数字, 存储到binary(16)中
3. 使用hex函数将16字节的数字转换为uuid字符串

```
mysql> select uuid();
+--------------------------------------+
| uuid()                               |
+--------------------------------------+
| e8dc60bb-6df3-11e8-8915-0800273063ab |
+--------------------------------------+
1 row in set

mysql> select unhex('e8dc60bb6df311e889150800273063ab');
+-------------------------------------------+
| unhex('e8dc60bb6df311e889150800273063ab') |
+-------------------------------------------+
| ��`�m��
+-------------------------------------------+
1 row in set

mysql> select hex(unhex('e8dc60bb6df311e889150800273063ab'));
+------------------------------------------------+
| hex(unhex('e8dc60bb6df311e889150800273063ab')) |
+------------------------------------------------+
| E8DC60BB6DF311E889150800273063AB               |
+------------------------------------------------+
1 row in set

```

ip数据需要转换为数字存储:

1. 使用无符号整数存储ip列
2. 使用inet_aton将ip字符串转换为整数
3. 使用inet_ntoa将数字转换为ip字符串

```
mysql> select inet_aton('192.168.0.1');
+--------------------------+
| inet_aton('192.168.0.1') |
+--------------------------+
|               3232235521 |
+--------------------------+
1 row in set

mysql> select inet_ntoa(3232235521);
+-----------------------+
| inet_ntoa(3232235521) |
+-----------------------+
| 192.168.0.1           |
+-----------------------+
1 row in set

```

## Schema的设计

### 范式与反范式

范式的主要目的:

- 减少数据冗余
- 消除插入/删除/更新的异常

关键概念:

- 码/键(候选码), 表中的一个或多个属性组K, 除开K中的属性外的其他所有属性都完全函数依赖于K, 则K为候选码; 一个表可能存在多个码
- 主属性, 包含在各个候选码中的属性, 主属性不可为空

通常使用的范式:

- 1NF(Normal Form)第一范式, 属性的原子性保证不可再分割, 每个属性都只能存储一个值
- 2NF第二范式, 基于1NF, 定义候选码, 非主属性必须**完全依赖**于候选码, 即通过候选码可以确定实体的唯一性
- 3NF第三范式, 基于2NF, 消除**传递依赖**, 即任何非主属性不能由其他属性派生, 要求**属性没有冗余**
- BCNF, 基于3NF的改进范式, 消除**主属性对码的部分与传递依赖**

一般情况下, 关系型数据库的表设计只要达到**3NF/BCNF**就够了.

```
// 不符合1NF, 电话列可继续拆分
学生|课程|老师|电话(手机, 座机)|教材|教室|上课时间 

// 符合1NF, 候选码为(学生, 课程), 但不符合2NF, 教材只部分依赖于主键列中的课程
学生|课程|老师|手机|座机|教材|教室|上课时间 

// 符合2NF, 但不符合3NF, (学生, 课程) => 老师 => 手机|座机, 存在传递依赖
学生|课程|老师|手机|座机|教室|上课时间

课程|教材

// 符合3NF
学生|课程|老师|教室|上课时间

课程|教材

老师|手机|座机

```

上面例子中的关系图:

![](./img/schema_data_type/example.jpg)




### id列的设计


## Reference

- [高性能MySQL](https://book.douban.com/subject/23008813/), 第4章 Schema与数据类型优化
- [解释一下关系数据库的第一第二第三范式](https://www.zhihu.com/question/24696366)
- [数据库设计三大范式与BCNF，学习笔记](https://www.cnblogs.com/ybwang/archive/2010/06/04/1751279.html)